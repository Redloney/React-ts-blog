{
  "pics": ["https://redspite.com/uploads/1616851608599.jpeg"],
  "_id": "605f32dafccc5d5c2169566e",
  "title": "React Hook 系列（二）：React hooks",
  "content": "<p>在React DevTools 中观察过 React 应用，你会发现由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。</p><p>组件维护越来越复杂，譬如事件监听逻辑要在不同的生命周期中绑定和解绑，复杂的页面componentDidMount包涵很多逻辑，代码阅读性变得很差。</p><p>class组件中的this难以理解，且class 不能很好的压缩，并且会使热重载出现不稳定的情况。更多引子介绍参见官方介绍。</p><p>所以hook就为解决这些问题而来：</p><ul><li>避免地狱式嵌套，可读性提高。</li><li>函数式组件，比class更容易理解。</li><li>class组件生命周期太多太复杂，使函数组件存在状态。</li><li>解决HOC和Render Props的缺点。</li><li>UI 和 逻辑更容易分离。</li></ul><blockquote>下面逐一介绍官方提供的hook API。</blockquote><h3>1. useState</h3><p><strong>? 函数组件有状态了</strong></p><p><code>const [state, setState] = useState(initialState);</code>&nbsp;state为变量，<code>setState</code>&nbsp;修改 state值的方法， setState也是异步执行。</p><p>DEMO1</p><p>class this.setState更新是state是合并， useState中setState是替换。</p><pre class=\"ql-syntax\" spellcheck=\"false\">function Example() {\n  // 声明一个叫 \"count\" 的 state 变量\n  const [count, setCount] = useState(0);\n    const [obj, setData] = useState();\n  return (\n    &lt;div&gt;\n      &lt;p&gt;You clicked {count} times&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n</pre><h3>2. useEffect</h3><p><strong>? 忘记生命周期，记住副作用</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">useEffect(()  =&gt;  {// Async Action}, ?[dependencies]); // 第二参数非必填\n</pre><p>DEMO2</p><pre class=\"ql-syntax\" spellcheck=\"false\">function Hook2() {\n  const [data, setData] = useState();\n  useEffect(() =&gt; {\n    console.log(\"useEffect\");\n  });\n  return (\n    &lt;div&gt;\n      {(() =&gt; {\n        console.log(\"render\");\n        return null;\n      })()}\n      &lt;p&gt;data: {JSON.stringify(data)}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\n</pre><p><strong>结论：</strong></p><ul><li>useEffect 是在render之后生效执行的。</li></ul><p>DEMO3</p><pre class=\"ql-syntax\" spellcheck=\"false\">import React, { useState, useEffect, useRef } from “react”;\nfunction Demo3() {\n  const [data, setData] = useState();\n  useEffect(() =&gt; {\n    console.log(\"useEffect—[]”);\n    fetch(“https://www.mxnzp.com/api/lottery/common/latest?code=ssq”)\n      .then(res =&gt; res.json())\n      .then(res =&gt; {\n        setData(res);\n      });\n  }, []);\n\n  useEffect(() =&gt; {\n    console.log(\"useEffect ---&gt; 无依赖\");\n  });\n\n  useEffect(() =&gt; {\n    console.log(“useEffect 依赖data： data发生了变化”);\n  }, [data]);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;data: {JSON.stringify(data)}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\nexport default Demo3;\n</pre><p><strong>结论：</strong></p><ul><li>effect在render后按照前后顺序执行。</li><li>effect在没有任何依赖的情况下，render后每次都按照顺序执行。</li><li>effect内部执行是异步的。</li><li>依赖<code>[]</code>可以实现类似<code>componentDidMount</code>的作用，但最好忘记生命周期， 只记副作用。</li></ul><p>DEMO4</p><pre class=\"ql-syntax\" spellcheck=\"false\">import React, { useState, useEffect, useRef } from \"react\";\n\nfunction Demo4() {\n  useEffect(() =&gt; {\n    console.log(“useEffect1”);\n    const timeId = setTimeout(() =&gt; {\n      console.log(“useEffect1-setTimeout-2000”);\n    }, 2000);\n    return () =&gt; {\n      clearTimeout(timeId);\n    };\n  }, []);\n  useEffect(() =&gt; {\n    console.log(\"useEffect2\");\n    const timeId = setInterval(() =&gt; {\n      console.log(\"useEffect2-setInterval-1000\");\n    }, 1000);\n    return () =&gt; {\n      clearInterval(timeId);\n    };\n  }, []);\n  return (\n    &lt;div&gt;\n      {(() =&gt; {\n        console.log(“render”);\n        return null;\n      })()}\n      &lt;p&gt;demo4&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\nexport default Demo4;\n</pre><p><strong>结论：</strong></p><ul><li>effect回调函数是按照先后顺序同时执行的。</li><li>effect的回调函数返回一个匿名函数，相当于<code>componentUnMount</code>的钩子函数，一般是remove eventLisenter， clear timeId等，主要是组件卸载后防止内存泄漏。</li></ul><blockquote>综上所述，useEffect 就是监听每当依赖变化时，执行回调函数的存在函数组件中的钩子函数。</blockquote><h3>3. useContext</h3><p><strong>跨组件共享数据的钩子函数</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">const value = useContext(MyContext);\n// MyContext 为 context 对象（React.createContext 的返回值） \n// useContext 返回MyContext的返回值。\n// 当前的 context 值由上层组件中距离当前组件最近的&lt;MyContext.Provider&gt; 的 value prop 决定。\n</pre><p>DEMO5</p><pre class=\"ql-syntax\" spellcheck=\"false\">import React, { useContext, useState } from “react”;\nconst MyContext = React.createContext();\nfunction Demo5() {\n  const [value, setValue] = useState(\"init”);\n  console.log(“Demo5”);\n  return (\n    &lt;div&gt;\n      {(() =&gt; {\n        console.log(\"render\");\n        return null;\n      })()}\n      &lt;button onClick={() =&gt; {\n        console.log('click：更新value')\n        setValue(`${Date.now()}_newValue`)\n      }}&gt;\n        改变value\n      &lt;/button&gt;\n      &lt;MyContext.Provider value={value}&gt;\n        &lt;Child1 /&gt;\n        &lt;Child2 /&gt;\n      &lt;/MyContext.Provider&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction Child1() {\n  const value = useContext(MyContext);\n  console.log(“Child1-value”, value);\n  return &lt;div&gt;Child1-value: {value}&lt;/div&gt;;\n}\n\nfunction Child2(props) {\n  console.log(‘Child2’)\n  return &lt;div&gt;Child2&lt;/div&gt;;\n}\n</pre><p><strong>结论：</strong></p><ul><li>useContext 的组件总会在 context 值变化时重新渲染， 所以<code>&lt;MyContext.Provider&gt;</code>包裹的越多，层级越深，性能会造成影响。</li><li><code>&lt;MyContext.Provider&gt;</code>&nbsp;的 value 发生变化时候， 包裹的组件无论是否订阅content value，所有组件都会从新渲染。</li><li>demo中child2 不应该rerender, 如何避免不必要的render？*</li><li>使用React.memo优化。</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">const Child2 = React.memo((props) =&gt; {\n  return &lt;div&gt;Child2&lt;/div&gt;;\n})\n</pre><p><strong>注意：</strong></p><p>默认情况下React.memo只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><p>参考链接</p><h3>4. useRef</h3><p>传送门</p><pre class=\"ql-syntax\" spellcheck=\"false\">const refContainer = useRef(initialValue);\n</pre><ul><li>useRef 返回一个可变的 ref 对象, 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象, 在整个组件的生命周期内是唯一的。</li><li>useRef 可以保存任何可变的值。其类似于在 class 中使用实例字段的方式。</li><li><strong>总结：</strong></li><li><em>useRef 可以存储那些不需要引起页面重新渲染的数据</em>。</li><li>如果你刻意地想要从某些异步回调中读取 /最新的/ state，你可以用 一个 ref 来保存它，修改它，并从中读取。</li></ul><h3>5. useReducer</h3><pre class=\"ql-syntax\" spellcheck=\"false\">const [state, dispatch] = useReducer(reducer, initialState);\n</pre><p><code>reducer</code>就是一个只能通过<code>action</code>将<code>state</code>从一个过程转换成另一个过程的纯函数;</p><p><code>useReducer</code>就是一种通过<code>(state,action) =&gt; newState</code>的过程，和<code>redux</code>工作方式一样。数据流： dispatch(action) =&gt; reducer更新state =&gt; 返回更新后的state</p><pre class=\"ql-syntax\" spellcheck=\"false\">const initialState = {count: 0};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return {count: state.count + 1};\n    case ‘decrement’:\n      return {count: state.count - 1};\n    default:\n      throw new Error();\n  }\n}\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    &lt;&gt;\n      Count: {state.count}\n      &lt;button onClick={() =&gt; dispatch({type: 'decrement'})}&gt;-&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch({type: 'increment'})}&gt;+&lt;/button&gt;\n    &lt;/&gt;\n  );\n}\n</pre><p><strong>官方推荐以下场景需要useReducer更佳：</strong></p><ul><li>state 逻辑较复杂且包含多个子值， 可以集中处理。</li><li>下一个 state 依赖于之前的 state 。</li><li>想更稳定的构建自动化测试用例。</li><li>想深层级修改子组件的一些状态，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为 你可以向子组件传递 dispatch 而不是回调函数 。</li><li>使用reducer有助于将读取与写入分开。</li><li class=\"ql-indent-1\">DEMO6</li></ul><pre class=\"ql-syntax\" spellcheck=\"false\">const fetchReducer = (state, action) =&gt; {\n  switch (action.type) {\n    case “FETCH_INIT\":\n      return {\n        ...state,\n        loading: true,\n        error: false\n      };\n    case “FETCH_SUCCESS”:\n      return {\n        ...state,\n        loading: false,\n        error: false,\n        data: action.payload\n      };\n    case \"FETCH_FAIL\":\n      return {\n        …state,\n        loading: false,\n        error: true\n      };\n    default:\n      throw new Error();\n  }\n};\n\nfunction Demo6() {\n  const [state, dispatch] = useReducer(fetchReducer, {\n    loading: false,\n    error: false,\n    msg: \"\",\n    data: {}\n  });\n\n  const getData = useCallback(async () =&gt; {\n    try {\n      dispatch({ type: \"FETCH_INIT\" });\n      const response = await fetch(\n        \"https://www.mxnzp.com/api/lottery/common/latest?code=ssq\"\n      );\n      const res = await response.json();\n\n      if (res.code) {\n        dispatch({ type: \"FETCH_SUCCESS\", payload: res.data });\n      } else {\n        dispatch({ type: “FETCH_FAIL”, payload: res.msg });\n      }\n    } catch (error) {\n      dispatch({ type: “FETCH_FAIL”, payload: error });\n    }\n  }, []);\n\n  useEffect(() =&gt; {\n    getData();\n  }, [getData]);\n\n  return (\n    &lt;Loading loading={state.loading}&gt;\n      &lt;p&gt;开奖号码： {state.data.openCode}&lt;/p&gt;\n    &lt;/Loading&gt;\n  );\n}\n</pre><p><code>demo6</code>useReducer处理了多个可以用useState实现的逻辑，包括<code>loading, error, msg, data</code>。</p><p><em>useContext 和 useReducer模拟redux管理状态</em></p><pre class=\"ql-syntax\" spellcheck=\"false\">import React, { useReducer, useContext } from “react”;\n\nconst ModalContext = React.createContext();\n\nconst visibleReducer = (state, action) =&gt; {\n  switch (action.type) {\n    case “CREATE”:\n      return { ...state, ...action.payload };\n    case \"EDIT\":\n      return { ...state, ...action.payload };\n    default:\n      return state;\n  }\n};\nfunction Demo7() {\n  const initModalVisible = {\n    create: false,\n    edit: false\n  };\n  const [state, dispatch] = useReducer(visibleReducer, initModalVisible);\n\n  return (\n    &lt;ModalContext.Provider value={{ visibles: state, dispatch }}&gt;\n      &lt;Demo7Child /&gt;\n    &lt;/ModalContext.Provider&gt;\n  );\n}\nfunction Demo7Child() {\n  return (\n    &lt;div&gt;\n      Demo7Child\n      &lt;Detail /&gt;\n    &lt;/div&gt;\n  );\n}\nfunction Detail() {\n  const { visibles, dispatch } = useContext(ModalContext);\n  console.log(\"contextValue\", visibles);\n  return (\n    &lt;div&gt;\n      &lt;p&gt;create: {`${visibles.create}`}&lt;/p&gt;\n      &lt;button\n        onClick={() =&gt; dispatch({ type: \"CREATE\", payload: { create: true } })}\n      &gt;\n        打开创建modal\n      &lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\nexport default Demo7;\n</pre><p>逻辑很清晰的抽离出来，context value中的值不需要在组件中透传，<em>即用即取</em>。DEMO7</p><blockquote><em>注意</em></blockquote><blockquote>React 会确保 dispatch 函数的标识是稳定的，并且不会在组件重新渲染时改变。这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 dispatch。</blockquote><h3>6. useCallback</h3><p><strong>语法：</strong></p><pre class=\"ql-syntax\" spellcheck=\"false\">const memoizedCallback = useCallback(\n  () =&gt; {\n    doSomething(a, b);\n  },\n  [a, b],\n);\n</pre><p>返回一个 memoized 回调函数。</p><p><code>useCallback</code>解决了什么问题？先看DEMO8</p><pre class=\"ql-syntax\" spellcheck=\"false\">import React, { useRef, useEffect, useState, useCallback } from “react”;\n\nfunction Child({ event, data }) {\n  console.log(\"child-render\");\n  // 第五版\n  useEffect(() =&gt; {\n    console.log(“child-useEffect”);\n    event();\n  }, [event]);\n  return (\n    &lt;div&gt;\n      &lt;p&gt;child&lt;/p&gt;\n      {/* &lt;p&gt;props-data: {data.data &amp;&amp; data.data.openCode}&lt;/p&gt; */}\n      &lt;button onClick={event}&gt;调用父级event&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\n\nconst set = new Set();\n\nfunction Demo8() {\n  const [count, setCount] = useState(0);\n  const [data, setData] = useState({});\n\n  // 第一版\n  // const handle = async () =&gt; {\n  //   const response = await fetch(\n  //     \"https://www.mxnzp.com/api/lottery/common/latest?code=ssq\"\n  //   );\n  //   const res = await response.json();\n  //   console.log(\"handle\", data);\n  //   setData(res);\n  // };\n\n  // 第二版\n  // const handle = useCallback(async () =&gt; {\n  //   const response = await fetch(\n  //     “https://www.mxnzp.com/api/lottery/common/latest?code=ssq\"\n  //   );\n  //   const res = await response.json();\n  //   console.log(“handle”, data);\n  //   setData(res);\n  // });\n\n  // 第三版\n  // const handle = useCallback(async () =&gt; {\n  //   const response = await fetch(\n  //     “https://www.mxnzp.com/api/lottery/common/latest?code=ssq”\n  //   );\n  //   const res = await response.json();\n  //   setData(res);\n  //   console.log(“useCallback”, data);\n  //   // eslint-disable-next-line react-hooks/exhaustive-deps\n  // }, []);\n\n  // // 第四版\n  // const handle = useCallback(async () =&gt; {\n  //   const response = await fetch(\n  //     “https://www.mxnzp.com/api/lottery/common/latest?code=ssq\"\n  //   );\n  //   const res = await response.json();\n  //   setData(res);\n  //   console.log(“parent-useCallback\", data);\n  //   // eslint-disable-next-line react-hooks/exhaustive-deps\n  // }, []);\n\n  // 第五版\n  const handle = useCallback(async () =&gt; {\n    const response = await fetch(\n      \"https://www.mxnzp.com/api/lottery/common/latest?code=ssq\"\n    );\n    const res = await response.json();\n    setData(res);\n    console.log(\"parent-useCallback\", data);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [count]);\n  set.add(handle);\n\n  console.log(“parent-render====&gt;”, data);\n  return (\n    &lt;div&gt;\n      &lt;button\n        onClick={e =&gt; {\n          setCount(count + 1);\n        }}\n      &gt;\n        count++\n      &lt;/button&gt;\n      &lt;p&gt;set size: {set.size}&lt;/p&gt;\n      &lt;p&gt;count:{count}&lt;/p&gt;\n      &lt;p&gt;data: {data.data &amp;&amp; data.data.openCode}&lt;/p&gt;\n      &lt;p&gt;-------------------------------&lt;/p&gt;\n      &lt;Child event={handle} /&gt;\n    &lt;/div&gt;\n  );\n}\nexport default Demo8;\n</pre><p><strong>结论：</strong></p><ul><li>第一版：每次render，handle都是新的函数，且每次都能拿到最新的data。</li><li>第二版：用useCallback包裹handle，每次render， handle也是新的函数，且每次都能拿到最新的data， 和一版效果一样， 所以不建议这么用。</li><li>第三版：useCallback假如第二个参数deps，handle会被memoized， 所以每次data都是第一次记忆时候的data（闭包）。</li><li>第四版： useCallback依赖count的变化，每当useCallback 变化时，handle会被重新memoized。</li><li>第五版：每当count变化时，传入子组件的函数都是最新的，所以导致child的useEffect执行。</li><li><strong>总结：</strong></li><li>useCallback将返回一个<em>记忆的回调版本</em>，仅在其中一个依赖项已更改时才更改。</li><li>当将回调传递给依赖于引用相等性的优化子组件以防止不必要的渲染时，此方法很有用。</li><li>使用回调函数作为参数传递，每次render函数都会变化，也会导致子组件rerender， useCallback可以优化rerender。</li><li><em>疑问：如何优化子组件不必要的渲染？</em></li></ul><h3>7. useMemo</h3><p><em>语法：</em></p><p><code>const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code>; 返回一个 memoized 值，和<code>useCallback</code>一样，当依赖项发生变化，才会重新计算 memoized 的值,。</p><p>useMemo和useCallback不同之处是：它允许你将&nbsp;<em>memoized</em>&nbsp;应用于任何值类型（不仅仅是函数）。</p><p>DEMO9</p><pre class=\"ql-syntax\" spellcheck=\"false\">import React, { useState, useMemo } from “react”;\n\nfunction Demo9() {\n  const [count, setCount] = useState(0);\n  const handle = () =&gt; {\n    console.log(“handle”, count);\n    return count;\n  };\n\n  const handle1 = useMemo(() =&gt; {\n    console.log(\"handle1\", count);\n    return count;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const handle2 = useMemo(() =&gt; {\n    console.log(“handle2”, count);\n      // 大计算量的方法\n    return count;\n  }, [count]);\n\n  console.log(\"render-parent\");\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;\n        demo9: {count}\n        &lt;button onClick={() =&gt; setCount(count + 1)}&gt;++count&lt;/button&gt;\n      &lt;/p&gt;\n      &lt;p&gt;-------------------&lt;/p&gt;\n      &lt;Child handle={handle1} /&gt;\n    &lt;/div&gt;\n  );\n}\n\nfunction Child({ handle }) {\n  console.log(\"render-child\");\n  return (\n    &lt;div&gt;\n      &lt;p&gt;child&lt;/p&gt;\n      &lt;p&gt;props-data: {handle}&lt;/p&gt;\n    &lt;/div&gt;\n  );\n}\nexport default Demo9;\n</pre><p><strong>总结：</strong></p><ul><li><code>useMemo</code>&nbsp;会在<code>render&nbsp;</code>前执行。</li><li>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。</li><li><code>useMemo</code>用于返回<code>memoize</code>,防止每次render时<em>大计算量</em>带来的开销。</li><li>使用<code>useMemo</code>优化需谨慎， 因为优化本身也带来了计算，<em>大多数时候，你不需要考虑去优化不必要的重新渲染</em>。</li></ul><h3>其他Hook</h3><h3>1. useImperativeHandle</h3><pre class=\"ql-syntax\" spellcheck=\"false\">// ref：需要传递的ref\n// createHandle: 需要暴露给父级的方法。\n// deps: 依赖\nuseImperativeHandle(ref, createHandle, [deps])\n</pre><p><code>useImperativeHandle</code>&nbsp;应当与<code>forwardRef&nbsp;</code>一起使用。先看DEMO10</p><pre class=\"ql-syntax\" spellcheck=\"false\">import React, {\n  useRef,\n  forwardRef,\n  useImperativeHandle,\n  useEffect,\n  useState\n} from \"react\";\n\nconst Child = forwardRef((props, ref) =&gt; {\n  const inputEl = useRef();\n  const [value, setVal] = useState(\"\");\n  // 第一版\n  // useImperativeHandle(ref, () =&gt; {\n  //   console.log(\"useImperativeHandle\");\n  //   return {\n  //     value,\n  //     focus: () =&gt; inputEl.current.focus()\n  //   };\n  // });\n\n  // 第二版\n  useImperativeHandle(\n    ref,\n    () =&gt; {\n      console.log(“useImperativeHandle\");\n      return {\n        value,\n        focus: () =&gt; inputEl.current.focus()\n      };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  return (\n    &lt;input\n      ref={inputEl}\n      onChange={e =&gt; setVal(e.target.value)}\n      value={value}\n      {...props}\n    /&gt;\n  );\n});\nfunction Demo10() {\n  const inputEl = useRef(null);\n\n  useEffect(() =&gt; {\n    console.log(“parent-useEffect”, inputEl.current);\n    inputEl.current.focus();\n  }, []);\n\n  function click() {\n    console.log(\"click:\", inputEl.current);\n    inputEl.current.focus();\n  }\n  console.log(“Demo10”, inputEl.current);\n  return (\n    &lt;div&gt;\n      &lt;Child ref={inputEl} /&gt;\n      &lt;button onClick={click}&gt;click focus&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}\nexport default Demo10;\n</pre><p><strong>结论：</strong></p><ul><li><code>useImperativeHandle</code>在当前组件render后执行。</li><li>第一版：没有deps，每当rerender时，<code>useImperativeHandle&nbsp;</code>都会执行， 且能拿到 state中最新的值, 父组件调用传入的方法也是最新。</li><li>第二版： 依赖<code>[]</code>，每当rerender时,<code>useImperativeHandle&nbsp;</code>不会执行，且不会更新到父组件。</li><li>第三版：依赖传入的state值&nbsp;<code>[value]</code>， 达到想要的效果。</li></ul><h3>2. useDebugValue</h3><p>不常用, 只能在React Developer Tools看到，详见官方传送门 。</p><p>DEMO11</p><pre class=\"ql-syntax\" spellcheck=\"false\">function useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(false);\n  // 在开发者工具中的这个 Hook 旁边显示标签\n  // e.g. \"FriendStatus: Online\"\n  useDebugValue(isOnline ? \"Online\" : \"Offline\");\n  return isOnline;\n}\nfunction Demo11() {\n  const isOnline = useFriendStatus(567);\n  return &lt;div&gt;朋友是否在线：{isOnline ? \"在线\" : \"离线\"}&lt;/div&gt;;\n}\n</pre><p>&lt;img src=\"http://blog.toringo.cn/20191212232411.png?guogai\" alt=\"image-20191212232215094\" style=\"zoom:30%;\" /&gt;</p><h3>3. useLayoutEffect</h3><p>很少用，与&nbsp;<code>useEffect</code>&nbsp;相同，但它会在所有的 DOM 变更之后同步调用 effect。</p>",
  "desc": "Hook 出现之前，组件之间复用状态逻辑很难，解决方案（HOC、Render Props）都需要重新组织组件结构， 且代码难以理解。",
  "createtime": "2020-03-25T16:00:00.000Z"
}